\section{设置HSM状态}
\subsection{通过文件标识符设置hsm状态}
\begin{lstlisting}[language={c++},numbers=left]
/* 此API的目的是通过文件标识符fd设置HSM状态*/
int llapi_hsm_state_set_fd(int fd, __u64 setmask, __u64 clearmask, __u32 archive_id);
\end{lstlisting}
该函数会新建一个如下的hsm state set结构的指针hss：
\begin{lstlisting}[language={c++},numbers=left]
struct hsm_state_set {
	__u32	hss_valid;
	// hss_valid初始设置为0x03
	__u32	hss_archive_id;
	/*  如果传入的archive_id大于0,则hss_valid设置为0x07, 
	并且hss_archive_id设置为传入archive_idhss_valid */
	__u64	hss_setmask;
	// hss_setmark设置得与传入参数一致
	__u64	hss_clearmask;
	// has_clearmask设置得与传入参数一致
};
\end{lstlisting}

之后调用ioctl函数：
\begin{lstlisting}[language={c++},numbers=left]
	rc = ioctl(fd, LL_IOC_HSM_STATE_SET, &hss);
	// 其中CMD命令为：
	LL_IOC_HSM_STATE_SET
	// 此命令实际为：
	#define LL_IOC_HSM_STATE_SET		_IOW('f', 212, struct hsm_state_set)
	// 它实际上使用IO write方法
	// 将hss指向的的hsm state set写入文件标识符fd所指的文件中
\end{lstlisting}


\subsection{通过文件路径设置hsm状态}
\begin{lstlisting}[language={c++},numbers=left]
	/* 此API的目的是通过文件路径path设置HSM状态*/
	int llapi_hsm_state_set(const char *path, __u64 setmask, __u64 clearmask, __u32 archive_id);
\end{lstlisting}
此API中重要步骤为：
\begin{lstlisting}[language={c++},numbers=left]
	/* 此函数通过open函数打开文件, 找到文件标识符fd */
	fd = open(path, O_WRONLY | O_LOV_DELAY_CREATE | O_NONBLOCK);
	/* 然后调用3.1中的函数修改hsm状态 */
	rc = llapi_hsm_state_set_fd(fd, setmask, clearmask, archive_id);
\end{lstlisting}

