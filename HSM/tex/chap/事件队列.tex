\section{HSM事件队列}

\subsection{注册HSM事件队列}

\begin{lstlisting}[language={c++},numbers=left]
    /* 此API的目的是通过文件路径path注册HSM事件队列
    该事件队列是为了监控进程可以从中读取
    而在没有读取器读取时，写入事件将丢失
    */
    int llapi_hsm_register_event_fifo(const char *path);
\end{lstlisting}
此API的重要实现为：
\begin{lstlisting}[language={c++},numbers=left]
    /* 从路径中读取(若读取不存在则新建)一个FIFO */
    mkfifo(path, 0644)
    /* 先以读取打开文件, 为了防止写指令不会马上失效 */
    read_fd = open(path, O_RDONLY | O_NONBLOCK);
    /*  再将HSM事件文件标识符指向该文件
        以非阻塞方式写入该队列 */
    llapi_hsm_event_fd = open(path, O_WRONLY | O_NONBLOCK);
\end{lstlisting}

\subsection{注销HSM事件队列}
\begin{lstlisting}[language={c++},numbers=left]
    /* 此API的目的是通过文件路径path注销HSM事件队列*/
    int llapi_hsm_unregister_event_fifo(const char *path);
\end{lstlisting}
此API的重要实现为：
\begin{lstlisting}[language={c++},numbers=left]
    /* 关闭队列的读取与写入 */
    close(llapi_hsm_event_fd)
    // 取消与path的连接
    unlink(path);
    // 设置HSM事件队列的存在标志位为否
    created_hsm_event_fifo = false;
    // 设置HSM事件文件夹标识符为-1
    llapi_hsm_event_fd = -1;
\end{lstlisting}

